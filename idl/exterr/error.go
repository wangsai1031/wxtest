// Code generated by xdtool gen. DO NOT EDIT.

package exterr

import (
	"fmt"
	"io"
)

const errcodeUndifined = -1

const (
	// E_ErrOk 成功
	E_ErrOk int64 = 0
	// E_DEFAULT_ERROR 系统错误
	E_DEFAULT_ERROR int64 = 99999
	// E_FORBIDDEN 没有权限
	E_FORBIDDEN int64 = 403
	// E_PARAM_ERROR 参数错误
	E_PARAM_ERROR int64 = 10400
	// E_TOKEN_ERROR token 错误
	E_TOKEN_ERROR int64 = 10401
	// E_DOWN_STREAM_RETURN_ERROR 调用下游错误
	E_DOWN_STREAM_RETURN_ERROR int64 = 10001
	// E_GET_DATA_ERROR 获取数据异常
	E_GET_DATA_ERROR int64 = 10002
	// E_INSERT_ERROR 数据入库失败
	E_INSERT_ERROR int64 = 10003
	// E_UPLOAD_FILE_ERROR 文件上传错误
	E_UPLOAD_FILE_ERROR int64 = 20001
)

// Msg 异常消息映射表
var Msg = map[int64]string{
	E_ErrOk:                    "成功",
	E_DEFAULT_ERROR:            "系统错误",
	E_FORBIDDEN:                "没有权限",
	E_PARAM_ERROR:              "参数错误",
	E_TOKEN_ERROR:              "token 错误",
	E_DOWN_STREAM_RETURN_ERROR: "调用下游错误",
	E_GET_DATA_ERROR:           "获取数据异常",
	E_INSERT_ERROR:             "数据入库失败",
	E_UPLOAD_FILE_ERROR:        "文件上传错误",
}

func New(code int64) error {
	message, _ := Msg[code]
	return &fundamental{
		code: code,
		msg:  message,
	}
}

func Errorf(code int64, format string, args ...interface{}) error {
	return &fundamental{
		code: code,
		msg:  fmt.Sprintf(format, args...),
	}
}

type fundamental struct {
	code int64
	msg  string
}

func (f *fundamental) Code() int64 {
	return f.code
}

func (f *fundamental) Error() string {
	return f.msg
}

func (f *fundamental) Format(s fmt.State, verb rune) {
	switch verb {
	case 'v':
		if s.Flag('+') {
			io.WriteString(s, f.msg)
			return
		}
		fallthrough
	case 's':
		io.WriteString(s, f.msg)
	}
}

func WithMessagef(err error, messageFmt string, arr ...interface{}) error {
	if err == nil {
		return nil
	}
	return &withMessage{
		cause: err,
		msg:   fmt.Sprintf(messageFmt, arr...),
	}
}

type withMessage struct {
	cause error
	msg   string
}

func (w *withMessage) Error() string { return w.cause.Error() }
func (w *withMessage) Code() int64 {
	type coder interface {
		Code() int64
	}

	if w.cause != nil {
		if code, ok := w.cause.(coder); ok {
			return code.Code()
		}
	}
	return errcodeUndifined
}
func (w *withMessage) Cause() error  { return w.cause }
func (w *withMessage) Unwrap() error { return w.cause }

func (w *withMessage) Format(s fmt.State, verb rune) {
	switch verb {
	case 'v':
		if s.Flag('+') {
			fmt.Fprintf(s, "%+v", w.Cause())
			io.WriteString(s, "; ")
			io.WriteString(s, w.msg)
			return
		}
		fallthrough
	case 's':
		io.WriteString(s, w.Error())
	}
}

func Wrap(err error, code int64) error {
	if err == nil {
		return nil
	}

	message, _ := Msg[code]

	return &wrapError{
		cause: err,
		code:  code,
		msg:   message,
	}
}

func Wrapf(err error, code int64, messageFmt string, arr ...interface{}) error {
	if err == nil {
		return nil
	}
	return &wrapError{
		cause: err,
		code:  code,
		msg:   fmt.Sprintf(messageFmt, arr...),
	}
}

type wrapError struct {
	cause error
	code  int64
	msg   string
}

func (w *wrapError) Error() string { return w.msg }
func (w *wrapError) Code() int64   { return w.code }
func (w *wrapError) Cause() error  { return w.cause }
func (w *wrapError) Unwrap() error { return w.cause }

func (w *wrapError) Format(s fmt.State, verb rune) {
	switch verb {
	case 'v':
		if s.Flag('+') {
			fmt.Fprintf(s, "%+v", w.Cause())
			io.WriteString(s, "; ")
			io.WriteString(s, w.msg)
			return
		}
		fallthrough
	case 's':
		io.WriteString(s, w.Error())
	}
}
